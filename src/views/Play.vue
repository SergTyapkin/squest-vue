<style lang="stylus" scoped>
@import "../styles/constants.styl"
@import "../styles/fonts.styl"

input-bg = linear-gradient(20deg, rgba(45, 36, 13, 0.4) 0%, rgba(62, 39, 17, 0.6) 50%, rgba(38, 30, 11, 0.4) 100%) 50% 50% no-repeat


.flex-root
  margin-top -70px
  padding-top 70px

.answer-form
  margin-top 20px
  padding 20px

.move-buttons
  margin-bottom 0
.top-buttons
  margin-top 0
  margin-bottom 0
.task-description
  font-medium-small()

  padding 20px
  line-height 1.05
  color textColor2
  border-bottom empColor6 1px solid
.restart-button
  > *
    text-align left

.qr-form
  width 100%
  max-width 460px
  margin-top 100px
  margin-right auto
  margin-left auto
  padding 40px 30px
  background linear-gradient(20deg, rgba(84, 67, 24, 0) 0%, rgb(88, 58, 24) 50%, rgba(84, 67, 24, 0) 100%) 50% 50% no-repeat
  border-radius 7px
  box-shadow 0 0 10px 0 rgba(162, 116, 14, 0.7), 0 0 15px 0 rgba(34, 28, 4, 0.4) inset
  transition all 0.3s ease
  .button-submit
    all unset
    cursor pointer
    box-sizing border-box
    width 100%
    margin-top 20px
    padding 10px
    font-family Arial
    font-size 1rem
    color textColor1
    text-align center
    background input-bg
    background linear-gradient(20deg, rgba(45, 36, 13, 0.4) 0%, rgba(90, 56, 25, 0.7) 50%, rgba(55, 43, 16, 0.4) 100%) 50% 50% no-repeat
    border 1px solid colorShadow
    border-color empColor3
    border-bottom 1px solid border-color
    border-radius 3px
    box-shadow input-box-shadow
    transition all 0.2s ease
    &:hover
      box-shadow inset 0 0 20px rgb(195, 162, 127), 0 0 15px rgb(255, 235, 164)

.congratulations
  width 100%
  text-align center
  .buttons
    text-align left

.stats
  .stats-container
    display flex
    align-items center
    justify-content center
    margin-bottom 20px
    > *
      margin 0 5px
    img
      width 30px
  .stars
    flex-direction row-reverse
    img
      cursor pointer
      transition all 0.3s ease
    img.checked
      transform scale(1.2)
    img:hover
      transform scale(1.3)

    img:hover ~ img
    img:hover    .randomwwl4dce9lhhdea2s,    .random0ukq8cji9ywn0u9f    .randomjlfudnmab1e9h27f,
    .randomx5767f94h1y2bsg9    .randomxjuvfgyd4aubumdn,    .randomujnnwiqri0sek1im
    .randoms3jjav1r3s9il5fr,    .randomd4bqsi537n2p7c28    .randompsr5hrlatzmskojr,    .randomtjfy7uj8qqsmp7up    .random73ie9f3ipzdh84gc,
    .randoms4t4qe29ktdjtyyf
    .random89oln501f6z1gf11,    .randomzm7rbtmoa9zhs1zr    .random7np8msm7ta8telfz,
    .randomqrr0illlw4ymnpe3    .randomyrx8gzfjwvfjq3g9,    .random6fxfkgx5x5xvro7o    .randomv8ftmeit6ce04s8n,
    .random59xva6kdy3yygc7y    .randomqqibi7xq6hx4f371,    .randomt4jg3vozyaclgq1m
    .random9ktkwqu7pko4nly7,    .random7ot3tp5ofbrl91to
    .randome3icic938vn2dx9f,    .randomzc79h2tkbs7spo14    .randomumgs2qkw736q1huk,
    .random3bk2aw5c2lz2vidx    .randomofmph8maybe9pmss,    .random9h66oijyj6mf4pw1
    .randomrgw4l5gpi1zpkyqz,    .randomczw4epzpcjifx3ty
    .randomhkuzdi6bc4p972qi,    .randomc7xd7g0a5e2hfl06    .randomtts8t641085zslr8,
    .randomwi73jj2x1nk5iesz    .random8hg1tgi7e5gw74bi,    .random4bjyiop4vg75auqp
    .randomdmgikl4j7tz98hm5,    .random54z6dok9loqm7dkj    .random6bo86w0rzvkpgy37,    .randomb8qs6j05qasepzzl    .randomrufu01zn33n40ucd,
    .randomp83i54gm1ch55x4a
    .randomn8uec9dve6hu485c,    .random52y5la0kcd1lvsgp    .randomxzkah2vxsk88s8in,
    .randomzhc261mutn1zxbty    .randomp1hbn7t1h9vljdc8,    .randompndptukxnj4b8l0e    .random6xsmskwzxvcd0kp3,
    .randomr4f334dr8kkgk1eq    .randoml3nwgcyjneum04ew,    .randomno4idn05xnz388fw
    .randomkiuunhnrhz01pygd,    .random9zorfjbpjnseoo2b
    .random96iwuiia1304alq1,    .randomeursf2ibadq19x72    .random3nvtw0d90kei1eyr,
    .randomimoa3ybsv8mgy3l1    .randomsjzo7u03q7wafpzr,    .randomsk9ilnt3mw94u7fq
    .randomlfhanwmtqctv9xic,    img:focus ~ img    .randomqvo2cyijxvkhdp0a,    .randomdqqp68tr99cq18qo    .random1xbqtl2d4wymsyq5,
    .randomv963ngz4wjf3f7ut    .randomgp52iugv15bcmlbj,    .randomcu6wdey8kdn2xxrk
    .random19xb557tp8v35cmr,    .randomp3gtpi7ko980554y    .randomi4lnksrqj692k7vg,    .random2i5z88tvebggfff9    .randomge4r7nhiiawgfkls,
    .random6k6nybw0us64z27t
    .randomsf2knoufqwivk99r,    .random3vm8uaj4ni3v43kq    .random6suec15gk339wl4u,
    .randomw0sl2oqlc9lzy9xu    .randoma5c32m3ghlunv4t0,    .randomzbi7852svhww4ajp    .random3qb1wiigrrfnjm46,
    .random27ugcseuf5bg286n    .randomgeidnozxid9t4xf1,    .randomricr3ujp1xjg25wf
    .randomijjgs36nuqczro5f,    .randomqvqxpo5zh4iag2ce
    .randomqdhp1fgcsuzmpltu,    .random69mwb7ljzrsosydp    .random2nwc0rf88huzoypl,
    .randomks1u3e4r5vdhe642    .randomp6h1tsusky8nx5fu,    .randomiuc4lee0q52y9962
    .random5ec070y4dmio9y1b,    .randomayepqjj3rdeirgrt
    .randomngeojqudfx3hjr3v,    .randomwl4fgwrkdib5c3vt    .randomh4myk8rrrjohpvow,
    .randomcja04wg170i69xx7    .random548g7g0fdubmagek,    .randomrlw5f2sxum3uvj3t
    .random28u5dhufwpm68qbh,    .randomftncvwmh4x4slx4t    .randomj2qo9zpe2n4hwmkt,    .randomhktmw2a1jmjsvt4z    .randomaofkmlddctiowzdg,
    .randomlr97iei6qrf9otwj
    .random9jp730wbqcrfu8i6,    .randomcwpcrmh7wtwqdbkn    .randommt1iwwa1tldli868,
    .randomfu2r1hdtsims0y4c    .randomg3miqyz4ge01yi4q,    .randompnwr8c132p20b1uv    .randomzhs9w9kmuep3wuma,
    .random2te3mcb1kd5gz7tu    .randommgncd74w9eowzpjw,    .random0zzvqryayroxx2sn
    .randomuu80g6vsa3e3zg7z,    .randomhuxsiad3f7ak2qzi
    .randomgnkq60k8pinrlcds,    .randomgb7lnmkt40ezlvjp    .randomd8ge82is3gpyyatv,
    .randomf0sft2h0xf1ws92j    .randomqnzod814491e589k,    .random453mmrndgn8wkh5b
    .random4tq0s32i2uyekuri,    img.checked
      color #d62a9d
      filter saturate(5)

    img.checked + img
      animation scaleup 0.5s

@keyframes scaleup
  from
    transform scale(1.4)
    color #600040

  to
    transform scale(1.3)
    color #d62a9d



.task-title
  font-large()

  display none
  width 100%
  margin-top 20px
  margin-bottom -10px
  color textColor1
  text-align center

.background
  position absolute
  z-index -1
  inset 0
  width 100%
  height 100%
  object-fit cover
  background mix(black, transparent)
</style>

<template>
  <div class="flex-root">
    <img class="background" v-if="backgroundImageUrl" :src="backgroundImageUrl" alt=" ">

    <TopButtons class="move-buttons" bg clickable arrows @click="changeProgress" :buttons="setProgressButtonsList" />
    <TopButtons
      class="top-buttons quest-info-panel"
      bg
      :buttons="[
        {name: taskTitle, description: `Квест: ${questTitle} <br> ${branchTitle ? `Ветка: ${branchTitle}` : 'В этом квесте задания можно проходить в любом порядке'}`}
      ]"
    />
    <TopButtons
      v-if="isTasksNotSorted && isTaskInUnsortedModeSelected && !isEnd"
      class="top-buttons"
      bg
      arrows
      clickable
      :buttons="[
        {name: 'К списку заданий'}
      ]"
      @click="() => {isTaskInUnsortedModeSelected = false; taskTitle = ''; taskId = undefined; taskDescription = ''}"
    />

    <CircleLoading v-if="loading" />
    <div v-show="isTasksNotSorted && !isTaskInUnsortedModeSelected && !isEnd">
      <ArrowListElement
        class="branch-tasks"
        ref="branchTasks"
        title="Задания"
        closed
        open-on-set-elements
        :elements="branchTasks"
        no-close
        @click-inside="onSelectTask"
      />
    </div>
    <div v-show="!isTasksNotSorted || isTaskInUnsortedModeSelected || isEnd" class="task-title-description-container">
      <div class="task-title">{{ taskTitle }}</div>
      <MarkdownRenderer ref="markdown" class="task-description text-middle" />
    </div>

    <div class="app-flex-filler" />

    <div v-if="isEnd" class="text-big-xx congratulations">
      <div>Вы прошли квест!</div>

      <div class="stats">
        <div class="text-middle stats-container">
          <img src="../res/time.svg" alt="time">
          Пройдено за: <b>{{ timeSpent }}</b>
        </div>
        <div>
          <div>Оценка:</div>
          <CircleLoading v-if="statsLoading" class="preview-image" />
          <div v-else class="stats-container stars" @click="sendVote">
            <img src="../res/star.svg" alt="5" :class="{checked: ratingVote >= 5}" @click="ratingVote = 5">
            <img src="../res/star.svg" alt="4" :class="{checked: ratingVote >= 4}" @click="ratingVote = 4">
            <img src="../res/star.svg" alt="3" :class="{checked: ratingVote >= 3}" @click="ratingVote = 3">
            <img src="../res/star.svg" alt="2" :class="{checked: ratingVote >= 2}" @click="ratingVote = 2">
            <img src="../res/star.svg" alt="1" :class="{checked: ratingVote >= 1}" @click="ratingVote = 1">
          </div>
        </div>
      </div>

      <TopButtons
        v-if="!$user.isTemporary"
        @click="restartOrFinish"
        class="buttons finish-buttons"
        bg
        clickable
        arrows
        big
        :buttons="[
          { name: 'Начать заново', description: 'Прогресс сохранится' },
          { name: 'Завершить квест'},
        ]"
      />
      <TopButtons
        v-else
        @click="finishTemporarySession"
        class="buttons finish-buttons"
        bg
        clickable
        arrows
        big
        no-left-arrow
        :buttons="[
          { name: 'Создать полноценный аккаунт'},
        ]"
      />
    </div>

    <Form
      v-else-if="!isQrAnswer && (!isTasksNotSorted || isTaskInUnsortedModeSelected)"
      ref="form"
      class="answer-form"
      :title="taskQuestion"
      :fields="[
        { title: 'ОТВЕТ', info: 'РеГиСтР не важен', jsonName: 'answer' },
      ]"
      submit-text="Ответить"
      @submit="checkAnswer"
      small-title
    />

    <div v-else-if="!isTasksNotSorted || isTaskInUnsortedModeSelected" class="qr-form">
      <!--      <div class="text-middle" v-if="answerLink">Отсканировано: {{answerLink}}</div>-->
      <QRScanner closed ref="qrScanner" @scan="checkQrAnswer" />
      <div class="text-small-x info">
        Как только ты отсканируешь правильный QR-код, ты пройдёшь это задание
      </div>
      <button class="button-submit" @click="clickOnScanButton">
        <transition name="opacity" mode="out-in">
          <span v-if="!$refs?.qrScanner?.active">Сканировать</span>
          <span v-else>Выключить сканнер</span>
        </transition>
      </button>
    </div>

    <Footer :links="bottomLink ? [bottomLink] : undefined" />
  </div>
</template>


<script>
import CircleLoading from "../components/loaders/CircleLoading.vue";
import Footer from "../components/Footer.vue";
import FloatingInput from "../components/FloatingInput.vue";
import QRScanner from "../components/QRScanner.vue";
import TopButtons from "../components/TopButtons.vue";
import MarkdownRenderer from "../components/MarkdownRenderer.vue";
import Form from "../components/FormExtended.vue";
import {secondsToStrTime} from "../utils/utils";
import {Themes, QuestModes} from "../constants";
import ArrowListElement from "~/components/ArrowListElement.vue";


const UPDATING_INTERVAL_MS = 8000;

export default {
  components: {ArrowListElement, MarkdownRenderer, TopButtons, QRScanner, FloatingInput, Footer, CircleLoading, Form},

  props: {
    testMode: Boolean,
    questId: Number,
    customCSS: String,
  },

  data() {
    return {
      questTitle: '',
      branchTitle: '',
      taskId: undefined,
      taskTitle: '',
      taskDescription: '',
      taskQuestion: '',
      isTasksNotSorted: false,
      backgroundImageUrl: undefined,
      customCSS: undefined,
      bottomLink: undefined,

      answer: '',
      answerLink: '',

      branchTasks: [],

      isTaskInUnsortedModeSelected: false,

      isEnd: false,
      isQrAnswer: false,
      isCanEdit: false,

      loading: false,
      answerLoading: false,
      statsLoading: false,

      isAnswerError: false,

      timeSpent: 0,
      ratingVote: 0,

      updatingInterval: undefined,

      customCSSStyleElement: undefined,

      setProgressButtonsList: [],

      Themes: Themes,
    }
  },

  mounted() {
    this.update();

    if (!this.testMode) {
      this.updatingInterval = setInterval(this.updatingProgressCheck, UPDATING_INTERVAL_MS);
    }
  },
  unmounted() {
    this.removeCSSFromDocument();

    clearInterval(this.updatingInterval);
  },

  methods: {
    async update(withLoading=true) {
      if (withLoading) this.loading = true;
      let res;
      if (this.testMode) {
        // if (this.questId === undefined) {
        //   throw new Error('questId не указан!');
        // }
        res = await this.$api.getExampleTask(this.questId);
      } else {
        res = await this.$api.getPlay();
      }
      if (withLoading) this.loading = false;

      if (!res.ok_) {
        if (!this.testMode) {
          if (res.status_ === 400) {
            this.$router.push({name: 'quests'});
            return;
          }

          this.$popups.error(`Ошибка ${res.status_}!`, res.info);
          return;
        } else {
          this.questTitle = "Название задания";
          this.branchTitle = "Название ветки квеста";
          this.backgroundImageUrl = null;
          this.customCSS = this.$props.customCSS;
          this.$user.progress = 1;
          this.isTasksNotSorted = false;
          this.isEnd = false;
          this.isCanEdit = false;
          this.taskId = null;
          this.taskTitle = "Название задания";
          this.taskDescription = "Какое-то достаточно длинное описание задания в квесте, которое *можно* **по-разному** `оформлять`, например ~~так~~, " +
            "- вот так" +
            "- и ещё вот так" +
            "И даже | делать | таблицы" +
            "-------| -------| -------" +
            "    1  |    2   |   3    ";
          this.$refs.markdown.update(res.description || '');
          this.taskQuestion = "Вопрос к заданию";
          this.isQrAnswer = false;
          return;
        }
      }

      this.questTitle = res.questtitle;
      this.branchTitle = res.branchtitle;
      this.backgroundImageUrl = res.backgroundimageurl;
      if (res.customcss !== this.customCSS) {
        this.removeCSSFromDocument();
        this.addCSSToDocument(res.customcss);
      }
      if (this.testMode) {
        this.customCSS = this.$props.customCSS;
      } else {
        this.customCSS = res.customcss;
      }
      this.bottomLink = res.bottomlink;
      this.$user.progress = res.progress;
      this.isTasksNotSorted = res.istasksnotsorted;
      this.isEnd = res.question === undefined;
      this.isCanEdit = res.canedit;
      if (this.isTasksNotSorted && !this.isEnd) {
        if (withLoading) this.loading = true;
        const res = await this.$api.getBranchTasks(this.$user.chosenbranchid, true);
        if (withLoading) this.loading = false;
        if (!res.ok_) {
          this.$popups.error('Ошибка', 'Не удалось получить список заданий в ветке');
          return;
        }
        this.branchTasks = res.tasks;
      } else {
        this.taskId = res.id;
        this.taskTitle = res.title;
        this.taskDescription = res.description;
        this.$refs.markdown.update(res.description || '');
        this.taskQuestion = res.question;
        this.isQrAnswer = res.isqranswer;
      }

      this.setProgressButtonsList = [];
      if (this.isCanEdit && !this.testMode) {
        if (this.isTasksNotSorted) {
          if (!this.isEnd) {
            this.setProgressButtonsList.push({name: '///', description: 'Эти кнопки есть только у автора квеста'});
            this.setProgressButtonsList.push({description: 'Пройти квест'});
          }
        } else {
          if (this.$user.progress < 1) {
            this.setProgressButtonsList.push({name: '///', description: 'Эти кнопки есть только у автора квеста'});
          } else {
            this.setProgressButtonsList.push({description: 'Предыдущее'});
          }
          if (this.$user.progress < this.$user.progressMax) {
            this.setProgressButtonsList.push({description: 'Следующее'});
          }
        }
      }

      if (!this.isEnd)
        return;

      if (withLoading) this.statsLoading = true;
      const stats = await this.$api.getMyBranchVotes(this.$user.chosenbranchid);
      if (withLoading) this.statsLoading = false;

      if (!stats.ok_) {
        this.$popups.error('Ошибка', 'Не удалось получить статистику прохождения');
        return;
      }
      this.timeSpent = secondsToStrTime(stats.time);
      this.ratingVote = stats.rating;
    },

    async updatingProgressCheck() {
      this.update(false);
    },

    async checkQrAnswer(answer) {
      if (answer === this.answerLink)
        return;
      this.answerLink = answer;

      const res = await this.checkAnswer({answer: this.answerLink});
      if (res) {
        this.$popups.success('Правильно', 'QR отсканирован');
        this.$refs.qrScanner.stop();
        return;
      }

      this.$popups.error('Неверно', 'Отсканирован неправильный QR');
    },

    async checkAnswer(values) {
      const showError = () => {
        if (this.$refs.form) {
          this.$refs.form.info = 'Ответ неверный';
          this.$refs.form.showError();
        }
        this.isAnswerError = true;
        setTimeout(() => {this.isAnswerError = false}, 1200);
      }
      if (this.testMode) {
        showError();
        return false;
      }

      this.answer = values.answer.trim();

      if (this.$refs.form)
        this.$refs.form.loading = true;
      this.answerLoading = true;
      const res = await this.$api.checkAnswer(this.answer);
      this.answerLoading = false;
      if (this.$refs.form)
        this.$refs.form.loading = false;

      if (res.ok_) {
        this.$popups.success('Правильно');
        values.answer = '';
        this.answer = '';
        this.isTaskInUnsortedModeSelected = false;
        this.taskId = '';
        this.taskTitle = '';
        this.taskDescription = '';
        await this.update();
        return true;
      }
      if (res.status_ === 418) {
        showError();
        return false;
      }

      this.$popups.error(`Ошибка ${res.status}!`, res.info);
      return false;
    },

    async restartOrFinish(button) {
      if (button.idx === 1) { // finish
        this.$router.push({name: 'quests'});
        await this.$api.chooseBranch(this.$user.chosenquestid, this.$user.chosenbranchid, QuestModes.normal);
        this.$store.dispatch('SET_THEME', Themes.default);
        return;
      }
      // restart
      if (!await this.$modal.confirm("Точно начинаем заново?", "Рейтинг останется")) {
        return;
      }
      this.loading = true;
      const res = await this.$api.restartBranch(this.$user.chosenbranchid);
      this.loading = false;
      if (!res.ok_) {
        this.$popups.error("Ошибка", "Не удалось начать заново");
        return;
      }
      await this.$api.chooseBranch(this.$user.chosenquestid, this.$user.chosenbranchid, QuestModes.normal);
      this.$store.dispatch('SET_THEME', Themes.default);
      await this.update();
    },
    async finishTemporarySession() {
      await this.$api.signOut();
      this.$store.dispatch('DELETE_USER');
      this.$router.push({name: "default"});
    },

    clickOnScanButton() {
      if (!this.$refs.qrScanner.active) {
        this.$refs.qrScanner.start();
        this.$refs.qrScanner.show();
        return;
      }
      this.$refs.qrScanner.stop();
      this.$refs.qrScanner.hide();
    },

    async sendVote() {
      if (!this.$user.isConfirmed) {
        this.$modal.alert("E-mail не подтвержден", "Из-за этого ты не можешь голосовать за рейтинг квеста. Подтвердить e-mail можно в профиле");
        return;
      }

      this.statsLoading = true;
      const res = await this.$api.voteBranchRating(this.$user.chosenbranchid, this.ratingVote);
      this.statsLoading = false;

      if (!res.ok_) {
        this.$popups.error('Ошибка', 'Не получилось сохранить голос');
        return;
      }
      this.$popups.success('Спасибо!', 'Вас голос очень важен для нас');
    },

    async changeProgress(buttonIdx) {
      if (this.isTasksNotSorted) {
        if (buttonIdx.idx === 0) {
          return;
        }
        this.statsLoading = true;
        const res = await this.$api.setBranchFinished(this.$user.chosenbranchid);
        this.statsLoading = false;
        if (!res.ok_) {
          this.$popups.error('Ошибка', 'Не получилось перейти на финиш');
          return;
        }

        this.update();
        return;
      }

      let addition = -1;
      if (buttonIdx.idx === 1)
        addition = +1;
      const targetProgress = this.$user.progress + addition;
      if (targetProgress < 0 || targetProgress > this.$user.progressMax)
        return;

      this.statsLoading = true;
      const res = await this.$api.setBranchProgress(this.$user.chosenbranchid, targetProgress);
      this.statsLoading = false;

      if (!res.ok_) {
        this.$popups.error('Ошибка', 'Не получилось перейти на другое задание');
        return;
      }
      this.update();
    },

    onSelectTask(task) {
      this.taskId = task.id;
      this.taskTitle = task.title;
      this.taskDescription = task.description;
      this.taskQuestion = task.question;
      this.isQrAnswer = task.isqranswer;
      this.isTaskInUnsortedModeSelected = true;
      this.$refs.markdown.update(this.taskDescription || '');
    },

    addCSSToDocument(stylesheetContent) {
      const headElement = document.head || document.getElementsByTagName("head")[0];
      const styleElement = document.createElement("style");
      styleElement.type = "text/css";
      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText = stylesheetContent;
      } else {
        styleElement.appendChild(document.createTextNode(stylesheetContent));
      }
      headElement.appendChild(styleElement);
      this.customCSSStyleElement = styleElement;
    },
    editCSSOnDocument(stylesheetContent) {
      if (!this.customCSSStyleElement) {
        return;
      }

      if (this.customCSSStyleElement.styleSheet) {
        this.customCSSStyleElement.styleSheet.cssText = stylesheetContent;
      } else {
        this.customCSSStyleElement.innerText = stylesheetContent;
      }
    },
    removeCSSFromDocument() {
      if (this.customCSSStyleElement) {
        this.customCSSStyleElement.remove();
      }
    }
  },

  watch: {
    '$props.customCSS'(to) {
      this.customCSS = to;
      this.editCSSOnDocument(to);
    }
  }
}
</script>
